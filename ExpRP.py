import math
from Node import Node

f = open("exprp_aar.txt", "w")
f_cpu = open("exprp_cpu.txt", "w")
f_ram = open("exprp_ram.txt", "w")
f_sto = open("exprp_storage.txt", "w")
f_as = open("exprp_active-slices.txt", "w")
f_revenue_time = open("exprp_revenue-time.txt", "w")

alpha = tuple()
system_components = int()
wtpr = float()
previous_acceptance_state = bool()
system_capacity = list()

S1 = Node(1, 1, 100, 100, 100)

def get_scarcity(previous_norm_util, currently_requested_resources):
    global alpha, system_components
    scarcity = (math.pow(2, previous_norm_util[0]) - 1) * currently_requested_resources[0] + \
               (math.pow(2, previous_norm_util[1]) - 1) * currently_requested_resources[1] + \
               (math.pow(2, previous_norm_util[2]) - 1) * currently_requested_resources[2]
    return scarcity

def get_utilization(prev_sys_util, requested_resources):
    global previous_acceptance_state
    if previous_acceptance_state:
        return [prev_sys_util[0] + requested_resources[0],
                prev_sys_util[1] + requested_resources[1],
                prev_sys_util[2] + requested_resources[2]]
    else:
        return prev_sys_util

def get_normalized_utilization(util):
    global wtpr, alpha, system_capacity
    return [math.floor((util[0] / system_capacity[0]) * math.log(wtpr * alpha[0])),
            math.floor((util[1] / system_capacity[1]) * math.log(wtpr * alpha[1])),
            math.floor((util[2] / system_capacity[2]) * math.log(wtpr * alpha[2]))]

def ExpRP(NSRs, max_slots, sample_pool, total_requests, p_min, p_max):
    global alpha, system_components, wtpr, previous_acceptance_state, system_capacity

    system_capacity = [S1[2], S1[3], S1[4]]  # Cloud
    aggregated_system_capacity = system_capacity[0] + system_capacity[1] + system_capacity[2]
   
    #######################################################################################################
    # Alpha: Capacity variation parameter. Ratio between aggregate capacities over all dimensions and single dimension capacity.
    alpha = (float(aggregated_system_capacity) / system_capacity[0],
             float(aggregated_system_capacity) / system_capacity[1],
             float(aggregated_system_capacity) / system_capacity[2])

    wtpr = p_max / p_min
    overall_system_util = [0, 0, 0]
    total_util = 0
    system_components = len(overall_system_util)
    normalized_system_utilization = [0., 0., 0.]

    no_accepted = 0
    # no_rejected = 0
    all_revenues = 0
    # sum_sl_lifetime = 0
    accumulated_value = 0
    accumulated_squares = 0
    slot = 0
    request_accumulator = 0
    accepted_requests = {}
    expired_slices = []

    while slot < max_slots:
        NSRs_in_current_slot = []

        number_of_requests_in_slot = NSRs[slot]

        first_sub_idx = request_accumulator
        last_sub_idx = request_accumulator + number_of_requests_in_slot

        for sub_idx in range(first_sub_idx, last_sub_idx):
            NSRs_in_current_slot.append(sample_pool[sub_idx])

        request_accumulator += number_of_requests_in_slot

        # print("#######################################################################################################")
        # print("Time Slot: ", slot)
        # print(len(NSRs_in_current_slot), " NSRs in Current Timeslot: ", NSRs_in_current_slot)
        # print("#######################################################################################################")
        # This is every request that is generated by system - can be accepted or rejected, active or expired.

        for request in NSRs_in_current_slot:
            request_value = request[4]
            all_revenues += request_value            
            system_current_available_resources = list(map(lambda x, y: x - y, system_capacity, overall_system_util))

            # print("Current Availability before decision: ", list(np.around(np.array(system_current_available_resources), 2)))
            cond_2 = all(x <= y for x, y in zip(request, system_current_available_resources))

            if request_value >= get_scarcity(normalized_system_utilization, request) and cond_2:
                # print("Request Accepted")
                previous_acceptance_state = True
                no_accepted += 1
                accepted_requests[no_accepted] = [*request, slot]
                accumulated_value += request_value
                accumulated_squares += request_value**2                

            else:
                # print("Request Rejected")
                previous_acceptance_state = False
                # no_rejected += 1

                # active_slices = [s for s in accepted_requests if s not in expired_requests]
                # print("Number of Active Slices: ", len(active_slices))

            # Update the system utilization for the next request
            overall_system_util = get_utilization(overall_system_util, request)
            normalized_system_utilization = get_normalized_utilization(overall_system_util)

        # Used to track the expired requests
        expired_requests = []
        # Check for expired slices in the accepted list of requests
        for old_request in accepted_requests.keys():
            if slot == accepted_requests[old_request][3] + accepted_requests[old_request][5]:  # reqs_[5] + reqs_[6]
                expired_requests.append(old_request)
                overall_system_util[0] -= accepted_requests[old_request][0]
                overall_system_util[1] -= accepted_requests[old_request][1]
                overall_system_util[2] -= accepted_requests[old_request][2]
                # active_slices = [s for s in accepted_requests if s not in expired_requests]
                # print("Number of Active Slices: ", len(active_slices))            

        # Remove expired slices from the accepted requests dict
        for expired_request_idx in expired_requests:
            del accepted_requests[expired_request_idx]

        slot += 1
        total_util += sum(overall_system_util)

    return float(accumulated_value), float(no_accepted), float(total_util), float(accumulated_squares)

#############################################################################################################
#############################################################################################################
def main(max_slots, fixed_NSRs, sample_pool, total_requests, pmin, pmax):

    return ExpRP(fixed_NSRs, max_slots, sample_pool, total_requests, pmin, pmax)
    
