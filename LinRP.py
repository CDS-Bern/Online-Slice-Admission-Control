import math
from Node import Node

f = open("linrp_aar.txt", "w")
f_cpu = open("linrp_cpu.txt", "w")
f_ram = open("linrp_ram.txt", "w")
f_sto = open("linrp_storage.txt", "w")
f_as = open("linrp_active-slices.txt", "w")
f_revenue_time = open("linrp_revenue-time.txt", "w")

alpha = tuple()
system_components = int()
wtpr = float()
previous_acceptance_state = bool()
system_capacity = list()

S1 = Node(1, 1, 100, 100, 100)

def get_scarcity(previous_norm_util, currently_requested_resources):
    global alpha, system_components
    return max(previous_norm_util[0] * math.sqrt((2 * alpha[0]) / system_components) * currently_requested_resources[0],
               previous_norm_util[1] * math.sqrt((2 * alpha[1]) / system_components) * currently_requested_resources[1],
               previous_norm_util[2] * math.sqrt((2 * alpha[2]) / system_components) * currently_requested_resources[2])

def get_utilization(prev_sys_util, requested_resources):
    global previous_acceptance_state
    if previous_acceptance_state:
        return [prev_sys_util[0] + requested_resources[0],
                prev_sys_util[1] + requested_resources[1],
                prev_sys_util[2] + requested_resources[2]]
    else:
        return prev_sys_util

def get_normalized_utilization(util):
    global wtpr, system_components, system_capacity
    return [math.floor((util[0] / system_capacity[0]) * math.sqrt(wtpr * system_components)),
            math.floor((util[1] / system_capacity[1]) * math.sqrt(wtpr * system_components)),
            math.floor((util[2] / system_capacity[2]) * math.sqrt(wtpr * system_components))]

def LinRP(NSRs, max_slots, sample_pool, total_requests, p_min, p_max):
    global alpha, system_components, wtpr, previous_acceptance_state, system_capacity

    system_capacity = [S1[2], S1[3], S1[4]]  # Cloud
    aggregated_system_capacity = system_capacity[0] + system_capacity[1] + system_capacity[2]
    # print("System Capacity: ", system_capacity, " Aggregated Capacity: ", aggregated_system_capacity)
   
    #######################################################################################################
    # Alpha: Capacity variation parameter. Ratio between aggregate capacities over all dimensions and single
    # dimension capacity.
    alpha = (float(aggregated_system_capacity) / system_capacity[0],
             float(aggregated_system_capacity) / system_capacity[1],
             float(aggregated_system_capacity) / system_capacity[2])

    wtpr = p_max / p_min
    overall_system_util = [0, 0, 0]
    total_util = 0
    system_components = len(overall_system_util)
    normalized_system_utilization = [0., 0., 0.]

    no_accepted = 0
    # no_rejected = 0
    all_revenues = 0
    # sum_sl_lifetime = 0
    accumulated_value = 0
    accumulated_squares = 0
    slot = 0
    request_accumulator = 0
    accepted_requests = {}
    expired_slices = []

    while slot < max_slots: # A slot has multiple requests

        NSRs_in_current_slot = []

        number_of_requests_in_slot = NSRs[slot]

        first_sub_idx = request_accumulator
        last_sub_idx = request_accumulator + number_of_requests_in_slot

        for sub_idx in range(first_sub_idx, last_sub_idx):
            NSRs_in_current_slot.append(sample_pool[sub_idx])

        request_accumulator += number_of_requests_in_slot

        # print("#######################################################################################################")
        # print("Time Slot: ", slot)
        # print(len(NSRs_in_current_slot), " NSRs in Current Timeslot: ", NSRs_in_current_slot)
        # print("#######################################################################################################")
        # This is every request that is generated by system - can be accepted or rejected, active or expired.

        for request in NSRs_in_current_slot:
            request_value = request[4]
            all_revenues += request_value
            
            # Admission Criteria:
            # Slice Request is Accepted - resource requirements are less than the capacity - simple policy.            
            current_available_system_resources = list(map(lambda x, y: x - y, system_capacity, overall_system_util))
            # print("Current Availability before decision: ", list(np.around(np.array(system_current_available_resources), 2)))
            cond_2 = all(x <= y for x, y in zip(request, current_available_system_resources))

            if request_value >= get_scarcity(normalized_system_utilization, request) and cond_2:
                # print("Request Accepted")
                previous_acceptance_state = True
                no_accepted += 1
                accepted_requests[no_accepted] = [*request, slot]
                accumulated_value += request_value
                accumulated_squares += request_value ** 2
                # active_slices = [s for s in accepted_requests if s not in expired_slices]
                # print("Number of Active Slices: ", len(active_slices))

            else:
                # print("Request Rejected")
                previous_acceptance_state = False
                # no_rejected += 1

                

            # Update the system utilization for the next request
            overall_system_util = get_utilization(overall_system_util, request)
            normalized_system_utilization = get_normalized_utilization(overall_system_util)

        # Used to track the expired requests
        expired_requests = []
        # Check for expired slices in the accepted list of requests
        for old_request in accepted_requests:
            if slot == accepted_requests[old_request][3] + accepted_requests[old_request][5]:  # reqs_[5] + reqs_[6]
                expired_requests.append(old_request)
                overall_system_util[0] -= accepted_requests[old_request][0]
                overall_system_util[1] -= accepted_requests[old_request][1]
                overall_system_util[2] -= accepted_requests[old_request][2]
                # active_slices = [s for s in accepted_requests if s not in expired_slices]
                # print("Number of Active Slices: ", len(active_slices))                

        # Remove expired slices from the accepted requests dict
        for expired_request_idx in expired_requests:
            del accepted_requests[expired_request_idx]

        slot += 1
        total_util += sum(overall_system_util)
    
    return float(accumulated_value), float(no_accepted), float(total_util), float(accumulated_squares)

#############################################################################################################
#############################################################################################################
def main(max_slots, fixed_NSRs, sample_pool, total_requests, pmin, pmax):

    return LinRP(fixed_NSRs, max_slots, sample_pool, total_requests, pmin, pmax)
