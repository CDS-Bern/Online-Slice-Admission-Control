import math
from Node import Node

f = open("linrp_aar.txt", "w")
f_cpu = open("linrp_cpu.txt", "w")
f_ram = open("linrp_ram.txt", "w")
f_sto = open("linrp_storage.txt", "w")
f_as = open("linrp_active-slices.txt", "w")
f_revenue_time = open("linrp_revenue-time.txt", "w")

alpha = tuple()
system_components = int()
wtpr = float()
previous_acceptance_state = bool()
system_capacity = list()

S1 = Node(1, 1, 100, 100, 100)

def get_scarcity(previous_norm_util, currently_requested_resources):
    global alpha, system_components
    return max(previous_norm_util[0] * math.sqrt((2 * alpha[0]) / system_components) * currently_requested_resources[0],
               previous_norm_util[1] * math.sqrt((2 * alpha[1]) / system_components) * currently_requested_resources[1],
               previous_norm_util[2] * math.sqrt((2 * alpha[2]) / system_components) * currently_requested_resources[2])

def get_utilization(prev_sys_util, requested_resources):
    global previous_acceptance_state
    if previous_acceptance_state:
        return [prev_sys_util[0] + requested_resources[0],
                prev_sys_util[1] + requested_resources[1],
                prev_sys_util[2] + requested_resources[2]]
    else:
        return prev_sys_util

def get_normalized_utilization(util):
    global wtpr, system_components, system_capacity
    return [math.floor((util[0] / system_capacity[0]) * math.sqrt(wtpr * system_components)),
            math.floor((util[1] / system_capacity[1]) * math.sqrt(wtpr * system_components)),
            math.floor((util[2] / system_capacity[2]) * math.sqrt(wtpr * system_components))]

def LinRP(NSRs, max_slots, sample_pool, total_requests, p_min, p_max):
    global alpha, system_components, wtpr, previous_acceptance_state, system_capacity

    system_capacity = [S1[2], S1[3], S1[4]]  # Cloud
    aggregated_system_capacity = system_capacity[0] + system_capacity[1] + system_capacity[2]
    # print("System Capacity: ", system_capacity, " Aggregated Capacity: ", aggregated_system_capacity)

    # E1 = [nodeCPU(), nodeRAM(), nodeSto()]  # Edge 1
    # E2 = [nodeCPU(), nodeRAM(), nodeSto()]  # Edge 2
    # E3 = [nodeCPU(), nodeRAM(), nodeSto()]  # Edge 3
    # E4 = [nodeCPU(), nodeRAM(), nodeSto()]  # Edge 4
    # R1 = [nodeCPU(), nodeRAM(), nodeSto()]  # RU 1
    # R2 = [nodeCPU(), nodeRAM(), nodeSto()]  # RU 2
    # R3 = [nodeCPU(), nodeRAM(), nodeSto()]  # RU 3

    #######################################################################################################
    # Alpha: Capacity variation parameter. Ratio between aggregate capacities over all dimensions and single
    # dimension capacity.
    alpha = (float(aggregated_system_capacity) / system_capacity[0],
             float(aggregated_system_capacity) / system_capacity[1],
             float(aggregated_system_capacity) / system_capacity[2])

    wtpr = p_max / p_min
    overall_system_util = [0, 0, 0]
    total_util = 0
    system_components = len(overall_system_util)
    normalized_system_utilization = [0., 0., 0.]

    no_accepted = 0
    # no_rejected = 0
    all_revenues = 0
    # sum_sl_lifetime = 0
    accumulated_value = 0
    accumulated_squares = 0
    slot = 0
    request_accumulator = 0
    accepted_requests = {}
    expired_slices = []

    while slot < max_slots: # A slot has multiple requests

        NSRs_in_current_slot = []

        number_of_requests_in_slot = NSRs[slot]

        first_sub_idx = request_accumulator
        last_sub_idx = request_accumulator + number_of_requests_in_slot

        for sub_idx in range(first_sub_idx, last_sub_idx):
            NSRs_in_current_slot.append(sample_pool[sub_idx])

        request_accumulator += number_of_requests_in_slot

        # print("#######################################################################################################")
        # print("Time Slot: ", slot)
        # print(len(NSRs_in_current_slot), " NSRs in Current Timeslot: ", NSRs_in_current_slot)
        # print("#######################################################################################################")
        # This is every request that is generated by system - can be accepted or rejected, active or expired.

        for request in NSRs_in_current_slot:
            request_value = request[4]
            all_revenues += request_value

            # print("###################################################################################################")
            # print("NSR:", slot, ":", a)
            # print("###################################################################################################")
            # print("Slice Request Value: ", round(v_i))
            # # print("")
            # print("Scarcity: ", round(scarcity))
            # print("CPU utilization: ", round(node_cpu_util, 1), "/", C[0])
            # print("RAM utilization: ", round(node_ram_util, 1), "/", C[1])
            # print("Storage utilization: ", round(sto_node_util, 1), "/", C[2])
            # print("")
            # print("Normalized CPU utilization: ", round(normalized_system_utilization[0], 3))
            # print("Normalized RAM utilization: ", round(normalized_system_utilization[1], 3))
            # print("Normalized Storage utilization: ", round(normalized_system_utilization[2], 3))
            # print("")

            # Admission Criteria:
            # Slice Request is Accepted - resource requirements are less than the capacity - simple policy.
            # Needs to be upgraded to consider FCFS and ExPRP policies
            current_available_system_resources = list(map(lambda x, y: x - y, system_capacity, overall_system_util))
            # print("Current Availability before decision: ", list(np.around(np.array(system_current_available_resources), 2)))
            cond_2 = all(x <= y for x, y in zip(request, current_available_system_resources))

            if request_value >= get_scarcity(normalized_system_utilization, request) and cond_2:
                # print("Request Accepted")
                previous_acceptance_state = True
                no_accepted += 1
                accepted_requests[no_accepted] = [*request, slot]
                accumulated_value += request_value
                accumulated_squares += request_value ** 2
                # active_slices = [s for s in accepted_requests if s not in expired_slices]
                # print("Number of Active Slices: ", len(active_slices))

                # if request[3] == 's1':
                #     s1 += 1
                # elif request[2] == 's2':
                #     s2 += 1
                # elif request[2] == 's3':
                #     s3 += 1

                # sum_sl_lifetime += request[3]

            else:
                # print("Request Rejected")
                previous_acceptance_state = False
                # no_rejected += 1

                # active_slices = [s for s in accepted_requests if s not in expired_slices]
                # print("Number of Active Slices: ", len(active_slices))

            # Update the system utilization for the next request
            overall_system_util = get_utilization(overall_system_util, request)
            normalized_system_utilization = get_normalized_utilization(overall_system_util)

        # Used to track the expired requests
        expired_requests = []
        # Check for expired slices in the accepted list of requests
        for old_request in accepted_requests:
            if slot == accepted_requests[old_request][3] + accepted_requests[old_request][5]:  # reqs_[5] + reqs_[6]
                expired_requests.append(old_request)
                overall_system_util[0] -= accepted_requests[old_request][0]
                overall_system_util[1] -= accepted_requests[old_request][1]
                overall_system_util[2] -= accepted_requests[old_request][2]
                # active_slices = [s for s in accepted_requests if s not in expired_slices]

        # Remove expired slices from the accepted requests dict
        for expired_request_idx in expired_requests:
            del accepted_requests[expired_request_idx]

        slot += 1
        total_util += sum(overall_system_util)

        # current_acceptance_ratio = float(no_accepted) / total_requests
        # print("Current Acceptance Ratio: ", current_acceptance_ratio)
        # curr_rej = round(no_rejected / total_requests, 3)
        # curr_req = round(no_requested / total_requests, 3)
        # curr_avail = round(sum_cpu / total_requests, 3)

        # f.write(str(current_acceptance_ratio) + ',' + str(slot) + '\n')

        # cpu_util = round((sum([nodeCPU() - node[0]]) / nodeCPU()) * 100, 3)
        # f_cpu.write(str(round(overall_system_util[0] / system_capacity[0], 2)) + ',' + str(slot) + '\n')

        # ram_util = round((sum([nodeRAM() - node[1]]) / nodeRAM()) * 100, 3)
        # f_ram.write(str(round(overall_system_util[1] / system_capacity[1], 2)) + ',' + str(slot) + '\n')

        # sto_util = round((sum([nodeSto() - node[2]]) / nodeSto()) * 100, 3)
        # f_sto.write(str(round(overall_system_util[2] / system_capacity[2], 2)) + ',' + str(slot) + '\n')

        # f_revenue_time.write(str(round(accumulated_value, 2)) + ',' + str(slot) + '\n')

        # f_as.write(str(len(set(accepted).difference(expired_slices))) + ',' + str(slot) + '\n')
    # return NSRs, max_slots
    # print("wtpr: ", wtpr)

    # f.close()
    # f_cpu.close()
    # f_ram.close()
    # f_sto.close()
    # f_as.close()
    # f_revenue_time.close()

    # print("###########################################################################################################")
    # print("###########################################################################################################")
    # print("Number of Requests: ", sum(NSRs))
    # print("Number of Accepted Requests: ", no_accepted)
    # print("Number of Rejected Requests: ", no_rejected)
    # print("Final Acceptance Ratio: ", round(no_accepted / sum(NSRs), 3))
    # print("Number of Accepted BE Slices: ", no_be)
    # print("Number of Accepted URLLC Slices: ", no_urllc)
    # print("Number of Accepted eMBB Slices: ", no_embb)
    # print("Average CPU Utilization (%): ", round(sum_cpu / C[0], 2))
    # print("Average RAM Utilization (%): ", round(sum_ram / C[1], 2))
    # print("Average Storage Utilization (%): ", round(sum_sto / C[2], 2))
    # print("Average Slice life time: ", round(sum_sl_lifetime / no_accepted, 1))
    # print("Final # of Active Slices: ", len(set(accepted).difference(expired_slices)))
    # active_slices = [s for s in accepted_requests if s not in expired_slices]
    # print("Number of Active Slices at end of Simulation: ", len(active_slices))
    # print("Number of Expired Slices at end of Simulation: ", len(expired_slices))
    # print("Number of Expired Slices: ", len(expired_slices))
    # print("Final Set of Active Slices: ", sorted(set(accepted).difference(expired_slices)))
    # print("Total Value of Accepted SRs: ", round(accumulated_value))
    # print("Total Value of All SRs: ", round(all_revenues))
    # print("Ratio - Accepted Values/Total Value: ", round(accumulated_value / all_revenues, 3))
    # print("Average Value of Accepted Slices: ", round(accumulated_value / len(accepted_requests)))
    # print("Max Value: ", round(max(all_revenues)))
    # print("Min Value: ", round(min(all_revenues)))
    # print()

    #############################################################################################################
    #############################################################################################################
    # a_ = np.genfromtxt("linrp_cpu.txt", delimiter=",", dtype=np.float64)
    # print("###################")
    # print("CPU")
    # c_ = loadtxt("linrp_cpu.txt", comments="#", delimiter=",", unpack=False, dtype=np.float64)
    # c = c_[:, 0]
    # cpu_mean = np.mean(c)
    # cpu_std = np.std(c)
    # cpu_upper = cpu_mean + cpu_std
    # cpu_lower = cpu_mean - cpu_std
    # print(cpu_upper)
    # print(round(cpu_mean, 3))
    # print(cpu_lower)
    # print("###################")
    #############################################################################################################
    #############################################################################################################
    # a_ = np.genfromtxt("linrp_cpu.txt", delimiter=",", dtype=np.float64)
    # print("RAM")
    # r_ = loadtxt("linrp_ram.txt", comments="#", delimiter=",", unpack=False, dtype=np.float64)
    # r = r_[:, 0]
    # ram_mean = np.mean(r)
    # ram_std = np.std(r)
    # ram_upper = ram_mean + ram_std
    # ram_lower = ram_mean - ram_std
    # print(ram_upper)
    # print(round(ram_mean, 3))
    # print(ram_lower)
    #############################################################################################################
    #############################################################################################################
    # a_ = np.genfromtxt("linrp_cpu.txt", delimiter=",", dtype=np.float64)
    # print("###################")
    # s_ = loadtxt("linrp_storage.txt", comments="#", delimiter=",", unpack=False, dtype=np.float64)
    # print("Storage")
    # s = s_[:, 0]
    # sto_mean = np.mean(s)
    # sto_std = np.std(s)
    # sto_upper = sto_mean + sto_std
    # sto_lower = sto_mean - sto_std
    # # print(sto_upper)
    # print(round(sto_mean, 3))
    # print("###################")
    # print(sto_lower)
    return float(accumulated_value), float(no_accepted), float(total_util), float(accumulated_squares)

#############################################################################################################
#############################################################################################################
def main(max_slots, fixed_NSRs, sample_pool, total_requests, pmin, pmax):

    return LinRP(fixed_NSRs, max_slots, sample_pool, total_requests, pmin, pmax)
    # Average Acceptance Ratio
    # linrp_aar()
    # # Utilization over time times
    # linrp_cpu()
    # linrp_ram()
    # linrp_storage()
    # linrp_as()

    # all_aar()
    # all_cpu()
    # all_mem()
    # all_sto()
    # rev_time()
    # policies_to_revenue()
    # cpu_cdf()
    # ram_cdf()
    # sto_cdf()
